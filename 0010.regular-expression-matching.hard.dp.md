## 1. 递归

如果没有*号,只要从左到右遍历比较就行了

```java
class Solution {
    public boolean isMatch(String text, String pattern) {
        if (pattern.isEmpty()) return text.isEmpty();
        boolean first_match = (!text.isEmpty() && (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));
        return first_match && isMatch(text.substring(1), pattern.substring(1));
    }
}
```

如果有了*号,那它出现在第二个位置上,并且这样将出现两种情况:

1. 没有匹配到的这个X*
2. 匹配了至少1个X

对于第一种情况,直接从pattern的第三位开始和s重新匹配: isMatch(s, p.substring(2))
对于第二种情况,判断第一个字符匹配了,并且继续从s的第二个字符开始匹配整个pattern


```java
class Solution {
    public boolean isMatch(String s, String p) {
        if(p.isEmpty()) return s.isEmpty();
        boolean firstMatch = (!s.isEmpty() && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.'));
        if(p.length() >= 2 && p.charAt(1) == '*')
            return (isMatch(s, p.substring(2)) || (firstMatch && isMatch(s.substring(1), p)));
        else
            return firstMatch && isMatch(s.substring(1), p.substring(1));
    }
}
```

## 2.1 Top-Down

对递归的优化,用中间变量来保存已经比较过的结果,提高速度

```java
class Solution {
    Boolean[][] memo;
    public boolean isMatch(String s, String p) {
        memo = new Boolean[s.length() + 1][p.length() + 1];
        return dp(0, 0, s, p);
    }

    private boolean dp(int i, int j, String s, String p) {
        if (memo[i][j] != null) {
            return memo[i][j] == Boolean.TRUE;
        }

        boolean ans = false;
        if (j == p.length()) {
            ans = i == s.length();
        } else {
            boolean firstMatch = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');

            if (j + 1 < p.length() && p.charAt(j + 1) == '*') {
                ans = dp(i, j + 2, s, p) || (firstMatch && dp(i + 1, j, s, p));
            } else {
                ans = firstMatch && dp(i + 1, j + 1, s, p);
            }
        }
        memo[i][j] = ans ? Boolean.TRUE : Boolean.FALSE;
        return ans;
    }
}
```

## 2.2 Down-Top 纯动态规划
